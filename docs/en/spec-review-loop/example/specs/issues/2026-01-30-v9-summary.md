# Spec Review Processing Summary — v9

Processed on: 2026-01-30

---

## Summary

| Issue ID | Title | Decision | Changes Applied | Guide Rule |
|----------|-------|----------|-----------------|------------|
| 1 | Booking search / fuzzy match data contract missing | Accepted | Added BookingSearchQuery and BookingSummary contracts; added Booking Resolution Flow section | G8 |
| 2 | Missing centralized contracts for service boundary responses and metadata overlay | Partially Accepted | Added ServiceErrorType enum and ActionMetadataOverlay contract; declined discriminated union formalization | G9 |
| 3 | Retry/attempt behavior inconsistent and uses hardcoded counts | Accepted | Replaced hardcoded "2" with configurable constraint; clarified self-correction vs auto-retry distinction | G3 |
| 4 | action_id constraints contradict OpenAPI operationId | Accepted | Removed snake_case constraint; action_id now preserves operationId format | Glossary/Canonical |

---

## Detailed Outcomes

### Issue 1: Booking search / fuzzy match data contract missing (Critical)

**Decision:** Accepted

**Changes Applied:**
- Added `BookingSearchQuery` contract to `contracts/data-definitions.md` — defines minimum fields needed for fuzzy search input
- Added `BookingSummary` contract to `contracts/data-definitions.md` — defines minimum fields needed for disambiguation UI
- Added "Booking Resolution Flow" subsection to LLM Planner component describing the 5-step resolution process
- Updated Open Questions to mark booking search response format as addressed (field requirements defined; exact API mapping is implementation detail)

**Rationale:** The spec correctly identified this as an open question, but G8 requires cross-module interfaces to be declared. The solution defines *what fields this service needs* while explicitly noting the ROLLER API mapping is implementation detail.

---

### Issue 2: Missing centralized contracts for service boundary responses and metadata overlay (High)

**Decision:** Partially Accepted

**Changes Applied:**
- Added `ServiceErrorType` enum to `contracts/data-definitions.md` (invalid_input / service_unavailable / auth_required)
- Added `ActionMetadataOverlay` contract to `contracts/data-definitions.md` formalizing the overlay structure
- Updated design spec to reference these centralized contracts
- Renamed existing `Error Type` enum to `Error Type (Action-Level)` for clarity

**Declined:** Creating `HandleBookingUpdateResponse` as a discriminated union — this is a language-specific pattern (TypeScript/Rust) and the response shapes are already clearly defined in the behavioral contract. The spec remains language-agnostic per design principles.

---

### Issue 3: Retry/attempt behavior inconsistent and uses hardcoded counts (High)

**Decision:** Accepted

**Changes Applied:**
- Changed "2 clarification attempts" to "bounded clarification attempts (configurable, small number)" in Planning Rules
- Changed "After 2 clarification attempts" to "After bounded clarification attempts" in Failure Modes table
- Clarified self-correction wording: changed "retry failed steps" to "re-attempt steps that failed due to correctable issues (e.g., 400 from bad format)"

**Note on perceived inconsistency:** The "retry" in self-correction and "no auto-retry" in error handling are NOT contradictory — self-correction refers to LLM fixing parameters and retrying within the ReAct loop, while "no auto-retry" refers to automatic re-execution after transient infrastructure errors (429, 5xx). The spec text now makes this distinction clearer.

**Declined:** Adding a retry policy matrix — the existing Error Classification table already defines behavior per error type and adding another matrix would be redundant.

---

### Issue 4: action_id constraints contradict OpenAPI operationId (High)

**Decision:** Accepted

**Changes Applied:**
- Changed `action_id` constraint from "unique, snake_case" to "unique, matches source operationId"
- Updated description to "Identifier derived from OpenAPI operationId (preserves original format)"

**Rationale:** Chose Option A (exact match) over Option B (normalize + traceability field) because:
1. Simpler implementation
2. Easier debugging (no translation needed when looking up API docs)
3. The snake_case constraint was speculative, not a real requirement

---

## Completion Status

All 4 issues from v9 have been processed:
- 3 fully accepted
- 1 partially accepted (discriminated union portion declined)

Spec files modified:
- `specs/contracts/data-definitions.md`
- `specs/2026-01-29-booking-updates-design.md`
